// GaborNoiseSpatialEnhancement.usf

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/Random.ush"
#include "utils.ush"

Texture2D input_foveated;
SamplerState LinearSampler;
Texture2D depth_texture;
RWTexture2D<float4> output_texture;
RWTexture2D<float4> output_noise_texture;

float2 foveation_center;
float screen_width_cm;
float screen_height_cm;
float distance_from_screen_cm;
float blur_rate_arcmin_per_degree;
float s_k;
uint cells;
uint impulses_per_cell;
uint seed;
float4x4 inv_view_projection_matrix;



float gabor_kernel(float2 offset, float freq, float theta)
{
	// Rotate offset by theta
	float cos_theta = cos(theta);
	float sin_theta = sin(theta);
	float2 rotated = float2(
		offset.x * cos_theta + offset.y * sin_theta,
		-offset.x * sin_theta + offset.y * cos_theta
	);

	// Gabor function
	float sigma = 0.5 / freq;
	float gaussian = exp(-dot(rotated, rotated) / (2.0 * sigma * sigma));
	float sinusoid = cos(2.0 * PI * freq * rotated.x);

	return gaussian * sinusoid;
}



// Reconstruct world position from depth buffer
float3 reconstruct_world_position(float2 uv, float2 texture_size)
{
	// Sample depth
	float depth = depth_texture.SampleLevel(LinearSampler, uv, 0).r;

	// Convert UV to NDC (Normalized Device Coordinates)
	float2 ndc_xy = uv * 2.0 - 1.0;
	ndc_xy.y = -ndc_xy.y; // Flip Y for Unreal's coordinate system

	// Reconstruct clip space position
	float4 clip_pos = float4(ndc_xy, depth, 1.0);

	// Transform to world space
	float4 world_pos = mul(clip_pos, inv_view_projection_matrix);
	world_pos.xyz /= world_pos.w; // Perspective divide

	return world_pos.xyz;
}

// Spatially-coherent Gabor noise synthesis in world space
float synthesize_spatial_gabor_noise(
	uint2 pixel_pos,
	float3 world_pos,
	uint2 texture_size,
	float F_L,
	float F_H,
	float amp,
	float theta,
	uint num_cells,
	uint num_impulses,
	uint base_seed)
{
	float noise = 0.0;

	// Cell size in world space (adjust this scale to control noise frequency)
	// 100 units total world space coverage divided by number of cells
	float cell_size = 100.0 / float(num_cells);

	// Determine which 3D cell this world position is in
	int3 world_cell = int3(floor(world_pos / cell_size));

	// Check surrounding cells in 3D space (3x3x3 = 27 cells)
	for (int dz = -1; dz <= 1; dz++)
	{
		for (int dy = -1; dy <= 1; dy++)
		{
			for (int dx = -1; dx <= 1; dx++)
			{
				int3 cell = world_cell + int3(dx, dy, dz);

				// Deterministic seed based on 3D cell position
				// Using large primes for good hash distribution
				uint cell_seed = base_seed;
				cell_seed = wang_hash(cell_seed + uint(cell.x) * 73856093u);
				cell_seed = wang_hash(cell_seed + uint(cell.y) * 19349663u);
				cell_seed = wang_hash(cell_seed + uint(cell.z) * 83492791u);
				uint rng_state = wang_hash(cell_seed);

				// Generate impulses deterministically for this cell
				for (uint i = 0; i < num_impulses; i++)
				{
					// Impulse position in world space (deterministic based on cell)
					float3 impulse_world;
					impulse_world.x = (float(cell.x) + random_float(rng_state)) * cell_size;
					impulse_world.y = (float(cell.y) + random_float(rng_state)) * cell_size;
					impulse_world.z = (float(cell.z) + random_float(rng_state)) * cell_size;

					// 3D offset from impulse to current world position
					float3 offset_3d = world_pos - impulse_world;

					// Project to screen-tangent plane for 2D Gabor evaluation
					// For now, just use XY (could be improved with view-aligned projection)
					float2 offset = offset_3d.xy;

					// Sample frequency (log-normal distribution)
					float log_mean = log(sqrt(F_L * F_H));
					float log_std = 0.25;
					float random_normal = sqrt(-2.0 * log(random_float(rng_state))) *
						cos(2.0 * PI * random_float(rng_state));
					float fcpp = exp(log_mean + log_std * random_normal);
					fcpp = clamp(fcpp, F_L, F_H);

					// Kernel radius in world space
					float kernel_radius = 3.5 / fcpp;

					if (length(offset) <= kernel_radius)
					{
						float kernel_val = gabor_kernel(offset, fcpp, theta);
						noise += amp * kernel_val;
					}
				}
			}
		}
	}

	return noise;
}


[numthreads(16, 16, 1)]
void gabor_foveated_spatial_enhance_cs(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 pixel_pos = DispatchThreadId.xy;
	uint2 texture_size;
	output_texture.GetDimensions(texture_size.x, texture_size.y);


	if (pixel_pos.x >= texture_size.x || pixel_pos.y >= texture_size.y)
	{
		return;
	}

	float2 uv = (float2(pixel_pos) + 0.5) / float2(texture_size);

	// Reconstruct world position from depth
	float3 world_pos = reconstruct_world_position(uv, float2(texture_size));

	// DO NOT RENDER FOVEA
	// TODO: add radius_fovea and radius_periphery here and use those instead.
	if (length(foveation_center - uv) <= 0.2f)
	{
		output_texture[pixel_pos] = float4(0.5f, 0.5f, 0.5f, 1.0f); // medium gray
		output_noise_texture[pixel_pos] = float4(0.0f, 0.0f, 0.0f, 1.0f); // no noise
		return;
	}

	float2 texel_size = 1.0 / float2(texture_size);

	float3 foveated = input_foveated.SampleLevel(LinearSampler, uv, 0).rgb;

	float ppd = pixels_per_degree(texture_size.x, screen_width_cm, distance_from_screen_cm);
	float2 foveation_center_pixels = foveation_center * float2(texture_size); // convert to pixels for radial_sigma_map
	float sigma_pix = radial_sigma_map(float2(pixel_pos), foveation_center_pixels, ppd, blur_rate_arcmin_per_degree);
	float2 freq_bounds = freq_bounds_cpp(sigma_pix, 1.0 / 512.0, 0.5);
	float F_L = freq_bounds.x;
	float F_H = freq_bounds.y;
	float theta = estimate_orientation(uv, input_foveated, LinearSampler, texel_size);

	// Amplitude from Laplacian (a = 0.25)
	float l_a = choose_laplacian_level_from_sigma(sigma_pix, 0.25);
	float amp = amplitude_from_laplacian(uv, input_foveated, LinearSampler, l_a, s_k);

	float w = smoothstep_custom(sigma_pix, 0.5, 2.0);
	amp *= w;

	// Use spatial Gabor noise instead of screen-space
	float noise = synthesize_spatial_gabor_noise(
		pixel_pos,
		world_pos,
		texture_size,
		F_L,
		F_H,
		amp,
		theta,
		cells,
		impulses_per_cell,
		seed);

	// Apply noise to luminance
	float Y = 0.2126 * foveated.r + 0.7152 * foveated.g + 0.0722 * foveated.b;
	float Yn = saturate(Y + noise);

	// Scale colour by luminance change
	float scale = (Yn + EPSILON) / (Y + EPSILON);
	float3 final_colour = saturate(foveated * scale);

	output_texture[pixel_pos] = float4(final_colour, 1.0);

	output_noise_texture[pixel_pos] = noise;

	// Test to see if noise works:
	//output_texture[pixel_pos] = float4(noise, noise, noise, 1.0f);

	// Debug: visualize world position
	//output_texture[pixel_pos] = float4(frac(world_pos * 0.1), 1.0f);

	// Debug: visualize depth
	//float depth = depth_texture.SampleLevel(LinearSampler, uv, 0).r;
	//output_texture[pixel_pos] = float4(depth, depth, depth, 1.0f);
}