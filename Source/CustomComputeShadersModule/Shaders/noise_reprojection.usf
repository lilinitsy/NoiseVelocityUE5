#include "/Engine/Private/Common.ush"

Texture2D input_foveated;
Texture2D previous_noise_texture;
Texture2D motion_vector_texture;
SamplerState point_sampler;
SamplerState linear_sampler;
RWTexture2D<float4> reprojected_noise_texture;
RWTexture2D<float4> output_texture;

[numthreads(16, 16, 1)]
void main_cs(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 pixel_pos = DispatchThreadId.xy;
	uint2 texture_size;

	reprojected_noise_texture.GetDimensions(texture_size.x, texture_size.y);

	if(pixel_pos.x >= texture_size.x || pixel_pos.y >= texture_size.y)
	{
		return;
	}

	float4 reprojected_noise = float4(0.0f, 0.0f, 0.0f, 0.0f);
	float2 uv = (float2(pixel_pos) + 0.5) / float2(texture_size);
	float4 pixel_colour = input_foveated.SampleLevel(point_sampler, uv, 0);
	float4 velocity_encoded = motion_vector_texture.SampleLevel(point_sampler, uv, 0); // Velocity is encoded as float4 and needs to be converted


	// Common.ush has EncodeVelocityToTexture and DecodeVelocityFromTexture functions
	float2 velocity_decoded = DecodeVelocityFromTexture(velocity_encoded);

	// Unreal encodes velocity with 0 at 0.5, 0.5, scale to get direction
	//velocity = velocity * 2.0f - 1.0f;
	//velocity.y *= -1.0f;

	float2 prev_uv = uv - velocity_decoded;
	bool valid = all(prev_uv >= 0.0) && all(prev_uv <= 1.0) && length(velocity_decoded) > 1e-2;

	if(valid)
	{
		reprojected_noise = previous_noise_texture.SampleLevel(point_sampler, prev_uv, 0);
	}

	// Reuse the noise in the same location
	else
	{
		reprojected_noise = previous_noise_texture.SampleLevel(point_sampler, uv, 0);
	}

	reprojected_noise_texture[pixel_pos] = reprojected_noise;
	output_texture[pixel_pos] = pixel_colour + reprojected_noise;

	// Debug: Visualize motion
	//reprojected_noise_texture[pixel_pos] = reprojected_noise;
	//output_texture[pixel_pos] = float4(velocity, 0.0f, 1.0f);

	// Debug: Is noise being written properly?
	//output_texture[pixel_pos] = previous_noise_texture.SampleLevel(point_sampler, uv, 0);

	// Debug: motion vector magnitude?
	//float velocity_mag = length(velocity);
	//output_texture[pixel_pos] = float4(velocity_mag, velocity_mag, velocity_mag, 1.0f);

}