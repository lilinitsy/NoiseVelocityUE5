#include "/Engine/Private/Common.ush"
#include "utils.ush"

Texture2D input_foveated;
Texture2D previous_noise_texture;
Texture2D motion_vector_texture;
SamplerState point_sampler;
SamplerState linear_sampler;
RWTexture2D<float4> reprojected_noise_texture;
RWTexture2D<float4> output_texture;

float2 foveation_center;
float screen_width_cm;
float screen_height_cm;
float distance_from_screen_cm;
float blur_rate_arcmin_per_degree;
float s_k;
uint cells;
uint impulses_per_cell;
uint seed;

float frequency_scale;
float time_seconds; // monotonic time
float phase_cycles_per_sec; // how many times per second it goes 0 -> 2PI -> 0
float phase_strength; // Probably needs to be tuned... oscillation strength, gets multipled by velocity.

// Stuff for rendering only the left / only the right side of the screen
uint region_mode; // 0 = FULLSCREEN, 1 = LEFT, 2 = RIGHT

float2 stretch_along_dir(float2 v, float2 dir_unit, float stretch)
{
	float2 d = dir_unit;
	float2 p = float2(-d.y, d.x);

	float t = dot(v, d);
	float u = dot(v, p);

	t /= max(stretch, EPSILON);

	return d * t + p * u;
}


float gabor_kernel_sigma_scaled(
	float2 offset,
	float freq,
	float theta,
	float envelope_scale,
	float phase_offset,
	float m_rot_x
)
{
	float2 rotated = rotate2d(offset, theta);

	float sigma = (0.5 / max(freq, 1e-6)) * max(envelope_scale, 1e-6);
	float gaussian = exp(-dot(rotated, rotated) / (2.0 * sigma * sigma));

	// Phase-shifted carrier (motion illusion)
	float phase = (2.0 * PI * freq * rotated.x) + (phase_offset * m_rot_x);
	float sinusoid = cos(phase);

	return gaussian * sinusoid;
}

float synthesize_gabor_noise_sigma_scaled(
	uint2 pixel_pos,
	uint2 texture_size,
	float F_L,
	float F_H,
	float amp,
	float theta,
	uint num_cells,
	uint num_impulses,
	uint rng_seed,
	float envelope_scale,
	float2 velocity,
	float phase_offset
)
{
	float noise = 0.0;

	uint cell_h = texture_size.y / num_cells;
	uint cell_w = texture_size.x / num_cells;

	int cell_y = int(pixel_pos.y / cell_h);
	int cell_x = int(pixel_pos.x / cell_w);

	// Motion directions projected into the Gabor frame (rotated)
	float m_rot_x = safe_normalize(rotate2d(velocity, theta)).x;


	for (int dy = -1; dy <= 1; dy++)
	{
		for (int dx = -1; dx <= 1; dx++)
		{
			int cy = cell_y + dy;
			int cx = cell_x + dx;

			if (cy < 0 || cy >= int(num_cells) || cx < 0 || cx >= int(num_cells))
			{
				continue;
			}
			uint y0 = uint(cy) * cell_h;
			uint x0 = uint(cx) * cell_w;

			uint y1 = min(texture_size.y, y0 + cell_h);
			uint x1 = min(texture_size.x, x0 + cell_w);

			if (x1 <= x0 || y1 <= y0)
			{
				continue;
			}

			uint cell_seed = rng_seed + uint(cy) * num_cells + uint(cx);
			uint rng_state = wang_hash(cell_seed);

			for (uint i = 0; i < num_impulses; i++)
			{
				uint impulse_y = (uint)random_int(rng_state, int(y0), int(y1));
				uint impulse_x = (uint)random_int(rng_state, int(x0), int(x1));

				float fl = F_L;
				float fh = F_H;
				float log_mean = log(sqrt(fl * fh));
				float log_std = 0.25;

				float u1 = max(random_float(rng_state), 1e-6);
				float u2 = random_float(rng_state);
				float random_normal = sqrt(-2.0 * log(u1)) * cos(2.0 * PI * u2);

				float fcpp = exp(log_mean + log_std * random_normal);
				fcpp = clamp(fcpp, fl, fh);

				float2 offset = float2(pixel_pos) - float2(impulse_x, impulse_y);

				float kernel_radius = (3.5 / max(fcpp, 1e-6)) * max(envelope_scale, 1.0);

				if (length(offset) <= kernel_radius)
				{
					float kernel_val = gabor_kernel_sigma_scaled(offset, fcpp, theta, envelope_scale, phase_offset, m_rot_x);
					noise += amp * kernel_val;
				}
			}
		}
	}

	return noise;
}

[numthreads(16, 16, 1)]
void selective_rerender_noise_cs(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 pixel_pos = DispatchThreadId.xy;
	uint2 texture_size;
	reprojected_noise_texture.GetDimensions(texture_size.x, texture_size.y);

	if (pixel_pos.x >= texture_size.x || pixel_pos.y >= texture_size.y)
	{
		return;
	}

	float2 uv = (float2(pixel_pos) + 0.5) / float2(texture_size);

	// Avoid speckling around fovea
	/*if (length(foveation_center - uv) <= 0.205f)
	{
		 //output_texture[pixel_pos] = float4(0.5f, 0.5f, 0.5f, 1.0f); // medium gray
		return;
	}*/



	float2 x_extents; // get it in pixel space, then convert to uv
	if (region_mode == 0) // full scene
	{
		x_extents = float2(0, texture_size.x);
	}

	else if (region_mode == 1) // left
	{
		x_extents = float2(0, texture_size.x / 2);
	}

	else // 2 (or more if somehow above): right
	{
		x_extents = float2(texture_size.x / 2, texture_size.x);
	}

	// x_extents.x: min x; x_extents.y: max x; make sure not to divide by the y of texture_size
	x_extents /= float2(texture_size.x, texture_size.x); // convert from pixel space to uv



	float3 foveated = input_foveated.SampleLevel(point_sampler, uv, 0).rgb;

	// Check that the bounds are proper to do noise
	if (uv.x >= x_extents.x && uv.x <= x_extents.y)
	{
		float4 velocity_encoded = motion_vector_texture.SampleLevel(point_sampler, uv, 0);
		float2 velocity_decoded = DecodeVelocityFromTexture(velocity_encoded);
		float velocity_magnitude = length(velocity_decoded);

		float noise_value = 0.0;
		float motion_threshold = 0.001;

		if (velocity_magnitude > motion_threshold)
		{
			float2 texel_size = 1.0 / float2(texture_size);
			float ppd = pixels_per_degree(texture_size.x, screen_width_cm, distance_from_screen_cm);
			float2 foveation_center_pixels = foveation_center * float2(texture_size);

			// sigma_ecc is in UV space
			float sigma_ecc = radial_sigma_map(float2(pixel_pos), foveation_center_pixels, ppd, blur_rate_arcmin_per_degree);
			float sigma_motion = max(0.0, velocity_magnitude * INV_SQRT_12); // sqrt(variance) of uniform distribution

			float sigma_eff = sqrt(sigma_ecc * sigma_ecc + sigma_motion * sigma_motion);

			float envelope_scale = sigma_eff / max(sigma_ecc, EPSILON);

			float2 freq_bounds = freq_bounds_cpp(sigma_eff, 1.0 / 512.0, 0.5);
			float F_L = freq_bounds.x * frequency_scale; // could scale here for lower or higher freq's
			float F_H = freq_bounds.y * frequency_scale; // could scale here for lower or higher freq's

			float theta = estimate_orientation(uv, input_foveated, linear_sampler, texel_size);
			float l_a = choose_laplacian_level_from_sigma(sigma_eff, 0.25);
			float amp = amplitude_from_laplacian(uv, input_foveated, linear_sampler, l_a, s_k);

			float w = smoothstep_custom(sigma_eff, 0.5, 2.0);
			amp *= w;

			// Compute the phase offset with time
			float base_phase = 2.0f * PI * frac(time_seconds * phase_cycles_per_sec);
			float phase_offset = base_phase * phase_strength * velocity_magnitude; // scale by motion

			noise_value = synthesize_gabor_noise_sigma_scaled(
				pixel_pos, texture_size,
				F_L, F_H,
				amp, theta,
				cells, impulses_per_cell,
				seed,
				envelope_scale,
				velocity_decoded,
				phase_offset);
		}
		else
		{
			noise_value = previous_noise_texture.SampleLevel(point_sampler, uv, 0).r;
		}

		reprojected_noise_texture[pixel_pos] = float4(noise_value, noise_value, noise_value, 1.0);

		float Y = 0.2126 * foveated.r + 0.7152 * foveated.g + 0.0722 * foveated.b;
		float Yn = saturate(Y + noise_value);
		float scale = (Yn + EPSILON) / (Y + EPSILON);
		float3 final_colour = saturate(foveated * scale);

		output_texture[pixel_pos] = float4(final_colour, 1.0);
	}

	else
	{
		output_texture[pixel_pos] = float4(foveated, 1.0);
	}
}
