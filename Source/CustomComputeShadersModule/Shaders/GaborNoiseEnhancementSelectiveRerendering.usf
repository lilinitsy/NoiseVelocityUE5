#include "/Engine/Private/Common.ush"

Texture2D input_foveated;
Texture2D previous_noise_texture;
Texture2D motion_vector_texture;
SamplerState point_sampler;
SamplerState linear_sampler;
RWTexture2D<float4> reprojected_noise_texture;
RWTexture2D<float4> output_texture;

float2 foveation_center;
float screen_width_cm;
float screen_height_cm;
float distance_from_screen_cm;
float blur_rate_arcmin_per_degree;
float s_k;
uint cells;
uint impulses_per_cell;
uint seed;

float time_seconds; // monotonic time
float phase_cycles_per_sec; // how many times per second it goes 0 -> 2PI -> 0
float phase_strength; // Probably needs to be tuned... oscillation strength, gets multipled by velocity.


#define PI 3.14159265359
#define EPSILON 1e-6
#define INV_SQRT_12 0.2886751345948129


float2 safe_normalize(float2 v)
{
	float len2 = dot(v, v);
	if (len2 < EPSILON)
	{
		return float2(1.0, 0.0);
	}
	return v * rsqrt(len2);
}

float2 rotate2d(float2 v, float theta)
{
	float c = cos(theta);
	float s = sin(theta);
	return float2(
		v.x * c + v.y * s,
		-v.x * s + v.y * c
	);
}

float2 stretch_along_dir(float2 v, float2 dir_unit, float stretch)
{
	float2 d = dir_unit;
	float2 p = float2(-d.y, d.x);

	float t = dot(v, d);
	float u = dot(v, p);

	t /= max(stretch, EPSILON);

	return d * t + p * u;
}

float pixels_per_degree(float screen_width_px, float screen_width_cm, float distance_cm)
{
	float cm_per_pixel = screen_width_cm / screen_width_px;
	float deg_rad = radians(1.0);
	float size_cm = 2.0 * distance_cm * tan(deg_rad / 2.0);
	float ppd = size_cm / cm_per_pixel;
	return ppd;
}

float radial_sigma_map(float2 pixel_pos, float2 gaze_pos, float ppd, float blur_rate)
{
	float dist_px = length(pixel_pos - gaze_pos);
	float dist_deg = dist_px / ppd;
	float blur_arcmin = blur_rate * dist_deg;
	float blur_deg = blur_arcmin / 60.0;
	float sigma_px = (blur_deg * ppd) / 2.355;
	return max(EPSILON, sigma_px);
}

float2 freq_bounds_cpp(float sigma_ecc, float fl_tbl_min, float fh_limit)
{
	float sigma_f = 1.0 / (2.0 * PI * max(EPSILON, sigma_ecc));
	float F_L = 3.0 * sigma_f;
	float F_H = fh_limit;
	F_L = clamp(F_L, fl_tbl_min, F_H * 0.999);
	return float2(F_L, F_H);
}

float choose_laplacian_level_from_sigma(float sigma_ecc, float a)
{
	float sigma_f = 1.0 / (2.0 * PI * max(EPSILON, sigma_ecc));
	float f_c = sqrt(-log(a)) / (PI * max(EPSILON, sigma_ecc));
	float l_a = -log2(max(EPSILON, f_c)) - 0.5;
	return l_a;
}

float smoothstep_custom(float x, float edge0, float edge1)
{
	float t = saturate((x - edge0) / (edge1 - edge0));
	return t * t * (3.0 - 2.0 * t);
}

float estimate_orientation(float2 uv, Texture2D tex, SamplerState samp, float2 texel_size)
{
	float tl = Luminance(tex.SampleLevel(samp, uv + float2(-1, -1) * texel_size, 0).rgb);
	float tc = Luminance(tex.SampleLevel(samp, uv + float2(0, -1) * texel_size, 0).rgb);
	float tr = Luminance(tex.SampleLevel(samp, uv + float2(1, -1) * texel_size, 0).rgb);
	float ml = Luminance(tex.SampleLevel(samp, uv + float2(-1, 0) * texel_size, 0).rgb);
	float mr = Luminance(tex.SampleLevel(samp, uv + float2(1, 0) * texel_size, 0).rgb);
	float bl = Luminance(tex.SampleLevel(samp, uv + float2(-1, 1) * texel_size, 0).rgb);
	float bc = Luminance(tex.SampleLevel(samp, uv + float2(0, 1) * texel_size, 0).rgb);
	float br = Luminance(tex.SampleLevel(samp, uv + float2(1, 1) * texel_size, 0).rgb);

	float gx = -tl + tr - 2.0 * ml + 2.0 * mr - bl + br;
	float gy = -tl - 2.0 * tc - tr + bl + 2.0 * bc + br;

	return atan2(gy, gx);
}

float sample_laplacian(float2 uv, Texture2D tex, SamplerState samp, float level)
{
	float3 current_mip = tex.SampleLevel(samp, uv, level).rgb;
	float3 lowres_mip = tex.SampleLevel(samp, uv, level + 1.0).rgb;
	float3 laplacian = current_mip - lowres_mip;
	return length(laplacian);
}

float amplitude_from_laplacian(float2 uv, Texture2D tex, SamplerState samp, float l_a, float s_k_val)
{
	int l0 = clamp(int(floor(l_a)), 0, 3);
	int l1 = clamp(l0 + 1, 0, 3);
	float t = frac(l_a);

	float A0 = sample_laplacian(uv, tex, samp, float(l0));
	float A1 = sample_laplacian(uv, tex, samp, float(l1));

	float amp = lerp(A0, A1, t);
	return s_k_val * amp;
}

uint wang_hash(uint seed_val)
{
	seed_val = (seed_val ^ 61) ^ (seed_val >> 16);
	seed_val *= 9;
	seed_val = seed_val ^ (seed_val >> 4);
	seed_val *= 0x27d4eb2d;
	seed_val = seed_val ^ (seed_val >> 15);
	return seed_val;
}

float random_float(inout uint state)
{
	state = wang_hash(state);
	return float(state) / 4294967296.0;
}

int random_int(inout uint state, int min_val, int max_val)
{
	return min_val + int(random_float(state) * float(max_val - min_val));
}

float gabor_kernel_sigma_scaled(
	float2 offset,
	float freq,
	float theta,
	float envelope_scale,
	float phase_offset,
	float m_rot_x
)
{
	float2 rotated = rotate2d(offset, theta);

	float sigma = (0.5 / max(freq, 1e-6)) * max(envelope_scale, 1e-6);
	float gaussian = exp(-dot(rotated, rotated) / (2.0 * sigma * sigma));

	// Phase-shifted carrier (motion illusion)
	float phase = (2.0 * PI * freq * rotated.x) + (phase_offset * m_rot_x);
	float sinusoid = cos(phase);

	return gaussian * sinusoid;
}

float synthesize_gabor_noise_sigma_scaled(
	uint2 pixel_pos,
	uint2 texture_size,
	float F_L,
	float F_H,
	float amp,
	float theta,
	uint num_cells,
	uint num_impulses,
	uint rng_seed,
	float envelope_scale,
	float2 velocity,
	float phase_offset
)
{
	float noise = 0.0;

	uint cell_h = texture_size.y / num_cells;
	uint cell_w = texture_size.x / num_cells;

	int cell_y = int(pixel_pos.y / cell_h);
	int cell_x = int(pixel_pos.x / cell_w);

	// Motion directions projected into the Gabor frame (rotated)
	float m_rot_x = safe_normalize(rotate2d(velocity, theta)).x;


	for (int dy = -1; dy <= 1; dy++)
	{
		for (int dx = -1; dx <= 1; dx++)
		{
			int cy = cell_y + dy;
			int cx = cell_x + dx;

			if (cy < 0 || cy >= int(num_cells) || cx < 0 || cx >= int(num_cells))
			{
				continue;
			}
			uint y0 = uint(cy) * cell_h;
			uint x0 = uint(cx) * cell_w;

			uint y1 = min(texture_size.y, y0 + cell_h);
			uint x1 = min(texture_size.x, x0 + cell_w);

			if (x1 <= x0 || y1 <= y0)
			{
				continue;
			}

			uint cell_seed = rng_seed + uint(cy) * num_cells + uint(cx);
			uint rng_state = wang_hash(cell_seed);

			for (uint i = 0; i < num_impulses; i++)
			{
				uint impulse_y = (uint)random_int(rng_state, int(y0), int(y1));
				uint impulse_x = (uint)random_int(rng_state, int(x0), int(x1));

				float fl = F_L;
				float fh = F_H;
				float log_mean = log(sqrt(fl * fh));
				float log_std = 0.25;

				float u1 = max(random_float(rng_state), 1e-6);
				float u2 = random_float(rng_state);
				float random_normal = sqrt(-2.0 * log(u1)) * cos(2.0 * PI * u2);

				float fcpp = exp(log_mean + log_std * random_normal);
				fcpp = clamp(fcpp, fl, fh);

				float2 offset = float2(pixel_pos) - float2(impulse_x, impulse_y);

				float kernel_radius = (3.5 / max(fcpp, 1e-6)) * max(envelope_scale, 1.0);

				if (length(offset) <= kernel_radius)
				{
					float kernel_val = gabor_kernel_sigma_scaled(offset, fcpp, theta, envelope_scale, phase_offset, m_rot_x);
					noise += amp * kernel_val;
				}
			}
		}
	}

	return noise;
}

[numthreads(16, 16, 1)]
void selective_rerender_noise_cs(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 pixel_pos = DispatchThreadId.xy;
	uint2 texture_size;
	reprojected_noise_texture.GetDimensions(texture_size.x, texture_size.y);

	if (pixel_pos.x >= texture_size.x || pixel_pos.y >= texture_size.y)
	{
		return;
	}

	float2 uv = (float2(pixel_pos) + 0.5) / float2(texture_size);
	float3 foveated = input_foveated.SampleLevel(point_sampler, uv, 0).rgb;

	float4 velocity_encoded = motion_vector_texture.SampleLevel(point_sampler, uv, 0);
	float2 velocity_decoded = DecodeVelocityFromTexture(velocity_encoded);
	float velocity_magnitude = length(velocity_decoded);

	float noise_value = 0.0;
	float motion_threshold = 0.001;

	if (velocity_magnitude > motion_threshold)
	{
		float2 texel_size = 1.0 / float2(texture_size);
		float ppd = pixels_per_degree(texture_size.x, screen_width_cm, distance_from_screen_cm);
		float2 foveation_center_pixels = foveation_center * float2(texture_size);

		// sigma_ecc is in UV space
		float sigma_ecc = radial_sigma_map(float2(pixel_pos), foveation_center_pixels, ppd, blur_rate_arcmin_per_degree);
		float sigma_motion = max(0.0, velocity_magnitude * INV_SQRT_12); // sqrt(variance) of uniform distribution

		float sigma_eff = sqrt(sigma_ecc * sigma_ecc + sigma_motion * sigma_motion);

		float envelope_scale = sigma_eff / max(sigma_ecc, EPSILON);

		float2 freq_bounds = freq_bounds_cpp(sigma_eff, 1.0 / 512.0, 0.5);
		float F_L = freq_bounds.x; // could scale here for lower or higher freq's
		float F_H = freq_bounds.y; // could scale here for lower or higher freq's

		float theta = estimate_orientation(uv, input_foveated, linear_sampler, texel_size);
		float l_a = choose_laplacian_level_from_sigma(sigma_eff, 0.25);
		float amp = amplitude_from_laplacian(uv, input_foveated, linear_sampler, l_a, s_k);

		float w = smoothstep_custom(sigma_eff, 0.5, 2.0);
		amp *= w;

		// Compute the phase offset with time
		float base_phase = 2.0f * PI * frac(time_seconds * phase_cycles_per_sec);
		float phase_offset = base_phase * phase_strength * velocity_magnitude; // scale by motion

		noise_value = synthesize_gabor_noise_sigma_scaled(
			pixel_pos, texture_size,
			F_L, F_H,
			amp, theta,
			cells, impulses_per_cell,
			seed,
			envelope_scale,
			velocity_decoded,
			phase_offset);
	}
	else
	{
		noise_value = previous_noise_texture.SampleLevel(point_sampler, uv, 0).r;
	}

	reprojected_noise_texture[pixel_pos] = float4(noise_value, noise_value, noise_value, 1.0);

	float Y = 0.2126 * foveated.r + 0.7152 * foveated.g + 0.0722 * foveated.b;
	float Yn = saturate(Y + noise_value);
	float scale = (Yn + EPSILON) / (Y + EPSILON);
	float3 final_colour = saturate(foveated * scale);

	output_texture[pixel_pos] = float4(final_colour, 1.0);
}
