// GaborNoiseEnhancement.usf

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/Random.ush"
#include "utils.ush"

Texture2D input_foveated;
SamplerState LinearSampler;
RWTexture2D<float4> output_texture;
RWTexture2D<float4> output_noise_texture;

float2 foveation_center;
float screen_width_cm;
float screen_height_cm;
float distance_from_screen_cm;
float blur_rate_arcmin_per_degree;
float s_k;
uint cells;
uint impulses_per_cell;
uint seed;

float frequency_scale;

uint region_mode;



float gabor_kernel(float2 offset, float freq, float theta)
{
	// Rotate offset by theta
	float cos_theta = cos(theta);
	float sin_theta = sin(theta);
	float2 rotated = float2(
		offset.x * cos_theta + offset.y * sin_theta,
		-offset.x * sin_theta + offset.y * cos_theta
	);
	
	// Modifying the frequency is messing up the colours

	// Gabor function
	float sigma = 0.5 / freq;
	float gaussian = exp(-dot(rotated, rotated) / (2.0 * sigma * sigma));
	float sinusoid = cos(2.0 * PI * freq * rotated.x);
	
	return gaussian * sinusoid;
}



float synthesize_gabor_noise(uint2 pixel_pos, 
							uint2 texture_size, 
							float F_L, 
							float F_H, 
							float amp, 
							float theta, 
							uint num_cells, 
							uint num_impulses, 
							uint rng_seed)
{
	float noise = 0.0;
	
	uint cell_h = texture_size.y / num_cells;
	uint cell_w = texture_size.x / num_cells;
	
	// Determine cell of this pixel
	int cell_y = int(pixel_pos.y) / int(cell_h);
	int cell_x = int(pixel_pos.x) / int(cell_w);
	
	// Check surrounding cells to catch kernel overlap (3x3 neighborhood)
	for (int dy = -1; dy <= 1; dy++)
	{
		for (int dx = -1; dx <= 1; dx++)
		{
			int cy = cell_y + dy;
			int cx = cell_x + dx;
			
			if (cy < 0 || cy >= int(num_cells) || cx < 0 || cx >= int(num_cells))
				continue;
				
			// Seed for this cell
			uint cell_seed = rng_seed + cy * num_cells + cx;
			uint rng_state = wang_hash(cell_seed);
			
			uint y0 = cy * cell_h;
			uint x0 = cx * cell_w;
			uint y1 = min(texture_size.y, y0 + cell_h);
			uint x1 = min(texture_size.x, x0 + cell_w);
			
			// Generate impulses for this cell
			for (uint i = 0; i < num_impulses; i++)
			{
				uint impulse_y = random_int(rng_state, y0, y1);
				uint impulse_x = random_int(rng_state, x0, x1);
				
				// Log-normal frequency sampling (matching Python's crude log-normal)
				float fl = F_L;
				float fh = F_H;
				float log_mean = log(sqrt(fl * fh));
				float log_std = 0.25;
				float random_normal = sqrt(-2.0 * log(random_float(rng_state))) * 
									cos(2.0 * PI * random_float(rng_state));
				float fcpp = exp(log_mean + log_std * random_normal);
				fcpp = clamp(fcpp, fl, fh);
				
				// Calculate offset from impulse to current pixel
				float2 offset = float2(pixel_pos) - float2(impulse_x, impulse_y);
				
				// Kernel size
				float kernel_radius = 3.5 / fcpp;
				
				if (length(offset) <= kernel_radius)
				{
					float kernel_val = gabor_kernel(offset, fcpp, theta);
					noise += amp * kernel_val;
				}
			}
		}
	}
	
	return noise;
}


[numthreads(16, 16, 1)]
void gabor_foveated_enhance_cs(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 pixel_pos = DispatchThreadId.xy;
	uint2 texture_size;
	output_texture.GetDimensions(texture_size.x, texture_size.y);


	if (pixel_pos.x >= texture_size.x || pixel_pos.y >= texture_size.y)
	{
		return;
	}
	
	float2 uv = (float2(pixel_pos) + 0.5) / float2(texture_size);
	
	// DO NOT RENDER FOVEA
	// TODO: add radius_fovea and radius_periphery here and use those instead.
	if (length(foveation_center - uv) <= 0.2f)
	{
		output_texture[pixel_pos] = float4(0.5f, 0.5f, 0.5f, 1.0f); // medium gray
		output_noise_texture[pixel_pos] = float4(0.0f, 0.0f, 0.0f, 1.0f); // no noise
		return;
	}

	float2 x_extents; // get it in pixel space, then convert to uv
	if (region_mode == 0) // full scene
	{
		x_extents = float2(0, texture_size.x);
	}

	else if (region_mode == 1) // left
	{
		x_extents = float2(0, texture_size.x / 2);
	}

	else // 2 (or more if somehow above): right
	{
		x_extents = float2(texture_size.x / 2, texture_size.x);
	}

	// x_extents.x: min x; x_extents.y: max x; make sure not to divide by the y of texture_size
	x_extents /= float2(texture_size.x, texture_size.x); // convert from pixel space to uv

	float3 foveated = input_foveated.SampleLevel(LinearSampler, uv, 0).rgb;

	if (uv.x >= x_extents.x && uv.x <= x_extents.y)
	{
		float2 texel_size = 1.0 / float2(texture_size);
	
		float ppd = pixels_per_degree(texture_size.x, screen_width_cm, distance_from_screen_cm);
		float2 foveation_center_pixels = foveation_center * float2(texture_size); // convert to pixels for radial_sigma_map
		float sigma_pix = radial_sigma_map(float2(pixel_pos), foveation_center_pixels, ppd, blur_rate_arcmin_per_degree);
		float2 freq_bounds = freq_bounds_cpp(sigma_pix, 1.0 / 512.0, 0.5);
		float F_L = freq_bounds.x * frequency_scale;
		float F_H = freq_bounds.y * frequency_scale;
		float theta = estimate_orientation(uv, input_foveated, LinearSampler, texel_size);
	
		// Amplitude from Laplacian (a = 0.25)
		float l_a = choose_laplacian_level_from_sigma(sigma_pix, 0.25);
		float amp = amplitude_from_laplacian(uv, input_foveated, LinearSampler, l_a, s_k);
	
		float w = smoothstep_custom(sigma_pix, 0.5, 2.0);
		amp *= w;
	
		float noise = synthesize_gabor_noise(pixel_pos, texture_size, F_L, F_H, amp, theta, cells, impulses_per_cell, seed);
		
		// Apply noise to luminance
		float Y = 0.2126 * foveated.r + 0.7152 * foveated.g + 0.0722 * foveated.b;
		float Yn = saturate(Y + noise);
	
		// Scale colour by luminance change
		float scale = (Yn + EPSILON) / (Y + EPSILON);
		float3 final_colour = saturate(foveated * scale);
	
		output_texture[pixel_pos] = float4(final_colour, 1.0);

		output_noise_texture[pixel_pos] = noise;
		// Test to see if noise works:
		//output_texture[pixel_pos] = float4(noise, noise, noise, 1.0f);
	}

	else
	{
		output_texture[pixel_pos] = float4(foveated, 1.0);
	}
}